import { useForm } from "@tanstack/react-form";
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { ArrowLeft, Plus, X, Edit2, Check, HelpCircle } from "lucide-react";
import { toast } from "sonner";
import { formatCurrencyInput, parseCurrencyInput, formatCurrency } from "~/lib/utils/currency";
import { useEffect, useState } from "react";
import { z } from "zod";
import { BILLING_CYCLES, type BillingCycle } from "~/lib/database";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "~/components/ui/alert-dialog";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { Switch } from "~/components/ui/switch";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "~/components/ui/tooltip";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { getAgent, saveAgent } from "~/lib/agents/agent.functions";
import { AgentSignal, type Agent } from "~/lib/database";

export const Route = createFileRoute("/agents/$agentId")({
  loader: async ({ params }) => {
    const agent = await getAgent({
      data: { agentId: params.agentId },
    });
    return { agent };
  },
  component: AgentFormPage,
});

type SignalForm = {
  id?: string;
  name: string;
  slug: string;
  pricePerCallCents: number;
};

type CreditSignalForm = {
  id?: string;
  name: string;
  friendlySignalIdentifier: string;
  creditsPerCallCents: number;
};

type SignalCardProps = {
  signal: SignalForm;
  index: number;
  isEditing: boolean;
  onEdit: () => void;
  onSave: (signal: Partial<SignalForm>) => void;
  onCancel: () => void;
  onRemove: () => void;
  computeSlug: (name: string) => string;
};

function SignalCard({ 
  signal, 
  isEditing, 
  onEdit, 
  onSave, 
  onCancel, 
  onRemove,
  computeSlug 
}: SignalCardProps) {
  const [editName, setEditName] = useState(signal.name);
  const [editPriceRaw, setEditPriceRaw] = useState("");
  const [editPriceCents, setEditPriceCents] = useState(signal.pricePerCallCents);

  // Initialize raw price when signal changes or editing starts
  useEffect(() => {
    if (isEditing && signal.pricePerCallCents > 0) {
      setEditPriceRaw(formatCurrencyInput(signal.pricePerCallCents));
    } else if (isEditing) {
      setEditPriceRaw("");
    }
    setEditPriceCents(signal.pricePerCallCents);
  }, [isEditing, signal.pricePerCallCents]);

  const handleSave = () => {
    // Parse the raw string into cents when saving
    const cents = parseCurrencyInput(editPriceRaw);
    onSave({
      name: editName,
      slug: computeSlug(editName),
      pricePerCallCents: cents,
    });
  };

  const handleCancel = () => {
    setEditName(signal.name);
    setEditPriceRaw(signal.pricePerCallCents > 0 ? formatCurrencyInput(signal.pricePerCallCents) : "");
    setEditPriceCents(signal.pricePerCallCents);
    onCancel();
  };

  if (isEditing) {
    return (
      <div className="space-y-4 border p-4 rounded-lg bg-muted/20">
        <div className="space-y-2">
          <Label>Signal Name</Label>
          <p className="text-sm text-muted-foreground">
            Give your signal a descriptive name that clearly identifies the operation being tracked.
          </p>
          <Input
            value={editName}
            onChange={(e) => setEditName(e.target.value)}
            placeholder="e.g., API Call, Data Processing, File Upload"
          />
        </div>
        <div className="space-y-2">
          <Label>Price per Usage (USD)</Label>
          <p className="text-sm text-muted-foreground">
            Set the cost charged each time this signal is triggered.
          </p>
          <Input
            type="text"
            value={editPriceRaw}
            onChange={(e) => {
              const value = e.target.value;
              if (value === '' || /^\d*\.?\d*$/.test(value)) {
                setEditPriceRaw(value);
              }
            }}
            onBlur={() => {
              if (editPriceRaw) {
                const cents = parseCurrencyInput(editPriceRaw);
                setEditPriceCents(cents);
                setEditPriceRaw(formatCurrencyInput(cents));
              }
            }}
            placeholder="Price in USD"
          />
        </div>
        <div className="flex gap-2">
          <Button
            type="button"
            onClick={handleSave}
            disabled={!editName.trim()}
          >
            <Check className="h-4 w-4 mr-2" />
            Save Signal
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={handleCancel}
          >
            <X className="h-4 w-4 mr-2" />
            Cancel
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex items-center justify-between p-3 border rounded-lg">
      <div>
        <p className="font-medium">{signal.name}</p>
        <p className="text-sm text-muted-foreground">
          ID: {signal.slug}
        </p>
        <p className="text-sm text-muted-foreground">
          Price: {formatCurrency(signal.pricePerCallCents)} per call
        </p>
      </div>
      <div className="flex gap-1">
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={onEdit}
        >
          <Edit2 className="h-4 w-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={onRemove}
        >
          <X className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

type CreditSignalCardProps = {
  signal: CreditSignalForm;
  index: number;
  isEditing: boolean;
  onEdit: () => void;
  onSave: (signal: Partial<CreditSignalForm>) => void;
  onCancel: () => void;
  onRemove: () => void;
  computeSlug: (name: string) => string;
};

function CreditSignalCard({ 
  signal, 
  isEditing, 
  onEdit, 
  onSave, 
  onCancel, 
  onRemove,
  computeSlug 
}: CreditSignalCardProps) {
  const [editName, setEditName] = useState(signal.name);
  const [editCreditsRaw, setEditCreditsRaw] = useState("");
  const [editCreditsCents, setEditCreditsCents] = useState(signal.creditsPerCallCents);

  // Initialize raw credits when signal changes or editing starts
  useEffect(() => {
    if (isEditing && signal.creditsPerCallCents > 0) {
      setEditCreditsRaw(formatCurrencyInput(signal.creditsPerCallCents));
    } else if (isEditing) {
      setEditCreditsRaw("");
    }
    setEditCreditsCents(signal.creditsPerCallCents);
  }, [isEditing, signal.creditsPerCallCents]);

  const handleSave = () => {
    // Parse the raw string into cents when saving
    const cents = parseCurrencyInput(editCreditsRaw);
    onSave({
      name: editName,
      slug: computeSlug(editName),
      creditsPerCallCents: cents,
    });
  };

  const handleCancel = () => {
    setEditName(signal.name);
    setEditCreditsRaw(signal.creditsPerCallCents > 0 ? formatCurrencyInput(signal.creditsPerCallCents) : "");
    setEditCreditsCents(signal.creditsPerCallCents);
    onCancel();
  };

  if (isEditing) {
    return (
      <div className="space-y-4 border p-4 rounded-lg bg-muted/20">
        <div className="space-y-2">
          <Label>Signal Name</Label>
          <p className="text-sm text-muted-foreground">
            Give your credit signal a descriptive name that clearly identifies the operation being tracked.
          </p>
          <Input
            value={editName}
            onChange={(e) => setEditName(e.target.value)}
            placeholder="e.g., Premium Feature Access, Advanced Analytics, Priority Support"
          />
        </div>
        <div className="space-y-2">
          <Label>Credits per Usage</Label>
          <p className="text-sm text-muted-foreground">
            Set the number of credits consumed each time this signal is triggered.
          </p>
          <Input
            type="text"
            value={editCreditsRaw}
            onChange={(e) => {
              const value = e.target.value;
              if (value === '' || /^\d*\.?\d*$/.test(value)) {
                setEditCreditsRaw(value);
              }
            }}
            onBlur={() => {
              if (editCreditsRaw) {
                const cents = parseCurrencyInput(editCreditsRaw);
                setEditCreditsCents(cents);
                setEditCreditsRaw(formatCurrencyInput(cents));
              }
            }}
            placeholder="Credits per call"
          />
        </div>
        <div className="flex gap-2">
          <Button
            type="button"
            onClick={handleSave}
            disabled={!editName.trim()}
          >
            <Check className="h-4 w-4 mr-2" />
            Save Signal
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={handleCancel}
          >
            <X className="h-4 w-4 mr-2" />
            Cancel
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex items-center justify-between p-3 border rounded-lg">
      <div>
        <p className="font-medium">{signal.name}</p>
        <p className="text-sm text-muted-foreground">
          ID: {signal.slug}
        </p>
        <p className="text-sm text-muted-foreground">
          Credits: {(signal.creditsPerCallCents / 100).toFixed(2)} per usage
        </p>
      </div> 
      <div className="flex gap-1">
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={onEdit}
        >
          <Edit2 className="h-4 w-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={onRemove}
        >
          <X className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

const formSchema = z.object({
  name: z.string().min(1, "Name is required"),
  agentSlug: z.string().min(1, "Slug is required"),
});

function AgentFormPage() {
  const navigate = useNavigate();
  const { agentId } = Route.useParams();
  const loaderData = Route.useLoaderData();
  const agent = loaderData.agent as Agent | null;

  const isNewAgent = agentId === "new";

  const [signals, setSignals] = useState<SignalForm[]>([]);
  const [newSignalName, setNewSignalName] = useState("");
  const [newSignalPriceRaw, setNewSignalPriceRaw] = useState("");
  const [newSignalPriceCents, setNewSignalPriceCents] = useState(0);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  
  const [setupFeeRaw, setSetupFeeRaw] = useState("");
  const [setupFeeCents, setSetupFeeCents] = useState(0);
  const [setupFeeEnabled, setSetupFeeEnabled] = useState(false);
  const [platformFeeRaw, setPlatformFeeRaw] = useState("");
  const [platformFeeCents, setPlatformFeeCents] = useState(0);
  const [platformFeeEnabled, setPlatformFeeEnabled] = useState(false);
  const [platformFeeBillingCycle, setPlatformFeeBillingCycle] = useState<BillingCycle>(BILLING_CYCLES.MONTHLY);
  const [showAddSignal, setShowAddSignal] = useState(false);
  
  const [outcomeSignals, setOutcomeSignals] = useState<SignalForm[]>([]);
  const [newOutcomeSignalName, setNewOutcomeSignalName] = useState("");
  const [newOutcomeSignalPriceRaw, setNewOutcomeSignalPriceRaw] = useState("");
  const [newOutcomeSignalPriceCents, setNewOutcomeSignalPriceCents] = useState(0);
  const [editingOutcomeIndex, setEditingOutcomeIndex] = useState<number | null>(null);
  const [showAddOutcomeSignal, setShowAddOutcomeSignal] = useState(false);
  
  const [creditSignals, setCreditSignals] = useState<CreditSignalForm[]>([]);
  const [newCreditSignalName, setNewCreditSignalName] = useState("");
  const [newCreditSignalCreditsRaw, setNewCreditSignalCreditsRaw] = useState("");
  const [newCreditSignalCreditsCents, setNewCreditSignalCreditsCents] = useState(0);
  const [editingCreditIndex, setEditingCreditIndex] = useState<number | null>(null);
  const [showAddCreditSignal, setShowAddCreditSignal] = useState(false);

  // Restricted agent state
  const [isRestrictedAgent, setIsRestrictedAgent] = useState(false);
  const [showRestrictedDialog, setShowRestrictedDialog] = useState(false);

  // Auto-enable restricted mode when fees are enabled
  useEffect(() => {
    if (setupFeeEnabled || platformFeeEnabled) {
      if (!isRestrictedAgent) {
        setIsRestrictedAgent(true);
        setShowRestrictedDialog(true);
      }
    }
  }, [setupFeeEnabled, platformFeeEnabled, isRestrictedAgent]);

  // Handle restricted agent change
  const handleRestrictedChange = (checked: boolean) => {
    if (checked) {
      setIsRestrictedAgent(true);
      setShowRestrictedDialog(true);
    } else {
      // Can't disable if fees are enabled
      if (setupFeeEnabled || platformFeeEnabled) {
        return; // Don't allow turning off
      }
      setIsRestrictedAgent(false);
    }
  };

  useEffect(() => {
    const agent = loaderData.agent;
    
    if (agent) {
      // Load fee settings
      setSetupFeeEnabled(agent.setupFeeEnabled || false);
      setSetupFeeCents(agent.setupFeeCents || 0);
      setSetupFeeRaw(agent.setupFeeCents ? formatCurrencyInput(agent.setupFeeCents) : "");
      setPlatformFeeEnabled(agent.platformFeeEnabled || false);
      setPlatformFeeCents(agent.platformFeeCents || 0);
      setPlatformFeeRaw(agent.platformFeeCents ? formatCurrencyInput(agent.platformFeeCents) : "");
      setPlatformFeeBillingCycle(agent.platformFeeBillingCycle || BILLING_CYCLES.MONTHLY);
      
      // Set restricted agent state
      setIsRestrictedAgent(Boolean(agent.setupFeeEnabled) || Boolean(agent.platformFeeEnabled));
      
      // Load usage signals
      if (agent.signals) {
        const existingSignals = agent.signals.map((signal: AgentSignal) => ({
          id: signal.id,
          name: signal.name,
          slug: signal.slug,
          pricePerCallCents: signal.pricePerCallCents || 0,
        }));
        setSignals(existingSignals);
      } else {
        setSignals([]);
      }
      
      // Load outcome signals
      if (agent.outcomeSignals) {
        const existingOutcomeSignals = agent.outcomeSignals.map((signal: AgentSignal) => ({
          id: signal.id,
          name: signal.name,
          slug: signal.slug,
          pricePerCallCents: signal.outcomePriceCents || 0,
        }));
        setOutcomeSignals(existingOutcomeSignals);
      } else {
        setOutcomeSignals([]);
      }
      
      // Load credit signals
      if (agent.creditSignals) {
        const existingCreditSignals = agent.creditSignals.map((signal: AgentSignal) => ({
          id: signal.id,
          name: signal.name,
          slug: signal.slug,
          creditsPerCallCents: signal.creditsPerCallCents || 0,
        }));
        setCreditSignals(existingCreditSignals);
      } else {
        setCreditSignals([]);
      }
    } else {
      // Reset all state for new agent
      setSignals([]);
      setOutcomeSignals([]);
      setCreditSignals([]);
      setSetupFeeEnabled(false);
      setSetupFeeCents(0);
      setSetupFeeRaw("");
      setPlatformFeeEnabled(false);
      setPlatformFeeCents(0);
      setPlatformFeeRaw("");
      setPlatformFeeBillingCycle(BILLING_CYCLES.MONTHLY);
      setIsRestrictedAgent(false);
    }
    
    // Reset editing state when switching agents
    setEditingIndex(null);
    setEditingOutcomeIndex(null);
    setEditingCreditIndex(null);
  }, [loaderData.agent]);

  const form = useForm({
    defaultValues: {
      name: agent?.name || "",
      agentSlug: agent?.agentSlug || "",
    },
    validators: {
      onChange: formSchema,
    },
    onSubmit: async ({ value }) => {
      try {
        await saveAgent({
          data: {
            agentId,
            name: value.name,
            agentSlug: value.agentSlug,
            // Fee fields
            setupFeeEnabled,
            setupFeeCents,
            platformFeeEnabled,
            platformFeeCents,
            platformFeeBillingCycle,
            // All signal types
            signals,
            outcomeSignals,
            creditSignals,
          },
        });

        toast.success(isNewAgent ? "Agent created successfully!" : "Agent updated successfully!");
        navigate({ to: "/agents" });
      } catch (error) {
        toast.error(isNewAgent ? "Failed to create agent" : "Failed to update agent");
        console.error("Error saving agent:", error);
      }
    },
  });

  // Compute friendly agent identifier from name
  const computeFriendlyIdentifier = (inputName: string) => {
    return inputName.toLowerCase().replace(/\s+/g, "-");
  };

  const handleCancel = () => {
    navigate({ to: "/agents" });
  };

  const handleAddSignal = () => {
    if (newSignalName.trim()) {
      // Parse the raw string into cents when adding the signal
      const cents = parseCurrencyInput(newSignalPriceRaw);
      const newSignal = {
        name: newSignalName,
        slug: computeSlug(newSignalName),
        pricePerCallCents: cents,
      };
      setSignals((prev) => [...prev, newSignal]);
      setNewSignalName("");
      setNewSignalPriceRaw("");
      setNewSignalPriceCents(0);
    }
  };

  const handleRemoveSignal = (index: number) => {
    setSignals((prev) => prev.filter((_, i) => i !== index));
    setEditingIndex(null);
  };

  const handleEditSignal = (index: number) => {
    setEditingIndex(index);
  };

  const handleSaveSignal = (index: number, updatedSignal: Partial<SignalForm>) => {
    setSignals((prev) => prev.map((signal, i) => 
      i === index ? { ...signal, ...updatedSignal } : signal
    ));
    setEditingIndex(null);
  };

  const handleCancelEdit = () => {
    setEditingIndex(null);
  };

  const handleAddOutcomeSignal = () => {
    if (newOutcomeSignalName.trim()) {
      const cents = parseCurrencyInput(newOutcomeSignalPriceRaw);
      const newSignal = {
        name: newOutcomeSignalName,
        slug: computeSlug(newOutcomeSignalName),
        pricePerCallCents: cents,
      };
      setOutcomeSignals((prev) => [...prev, newSignal]);
      setNewOutcomeSignalName("");
      setNewOutcomeSignalPriceRaw("");
      setNewOutcomeSignalPriceCents(0);
    }
  };

  const handleRemoveOutcomeSignal = (index: number) => {
    setOutcomeSignals((prev) => prev.filter((_, i) => i !== index));
    setEditingOutcomeIndex(null);
  };

  const handleEditOutcomeSignal = (index: number) => {
    setEditingOutcomeIndex(index);
  };

  const handleSaveOutcomeSignal = (index: number, updatedSignal: Partial<SignalForm>) => {
    setOutcomeSignals((prev) => prev.map((signal, i) => 
      i === index ? { ...signal, ...updatedSignal } : signal
    ));
    setEditingOutcomeIndex(null);
  };

  const handleCancelOutcomeEdit = () => {
    setEditingOutcomeIndex(null);
  };

  const handleAddCreditSignal = () => {
    if (newCreditSignalName.trim()) {
      // Parse the raw string into cents when adding the signal
      const cents = parseCurrencyInput(newCreditSignalCreditsRaw);
      const newSignal = {
        name: newCreditSignalName,
        slug: computeSlug(newCreditSignalName),
        creditsPerCallCents: cents,
      };
      setCreditSignals((prev) => [...prev, newSignal]);
      setNewCreditSignalName("");
      setNewCreditSignalCreditsRaw("");
      setNewCreditSignalCreditsCents(0);
    }
  };

  const handleRemoveCreditSignal = (index: number) => {
    setCreditSignals((prev) => prev.filter((_, i) => i !== index));
    setEditingCreditIndex(null);
  };

  const handleEditCreditSignal = (index: number) => {
    setEditingCreditIndex(index);
  };

  const handleSaveCreditSignal = (index: number, updatedSignal: Partial<CreditSignalForm>) => {
    setCreditSignals((prev) => prev.map((signal, i) => 
      i === index ? { ...signal, ...updatedSignal } : signal
    ));
    setEditingCreditIndex(null);
  };

  const handleCancelCreditEdit = () => {
    setEditingCreditIndex(null);
  };

  return (
    <div className="p-8">
      <Button variant="ghost" onClick={handleCancel} className="mb-6">
        <ArrowLeft className="h-4 w-4 mr-2" />
        Back to Agents
      </Button>

      <div className="flex gap-6 max-w-6xl">
        <Card className="flex-1 max-w-2xl">
        <CardHeader>
          <CardTitle>
            {isNewAgent ? "Create New Agent" : "Edit Agent"}
          </CardTitle>
          <CardDescription>
            {isNewAgent
              ? "Add a new AI agent to your system"
              : "Update agent information"}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={(e) => {
              e.preventDefault();
              e.stopPropagation();
              form.handleSubmit();
            }}
            className="space-y-6"
          >
            <form.Field name="name">
              {(field) => (
                <div className="space-y-2">
                  <Label htmlFor={field.name}>Agent Name</Label>
                  <p className="text-sm text-muted-foreground">
                    Give your agent a descriptive name. This will be used to
                    auto-generate a unique Agent ID.
                  </p>
                  <Input
                    id={field.name}
                    name={field.name}
                    value={field.state.value}
                    onChange={(e) => field.handleChange(e.target.value)}
                    onBlur={field.handleBlur}
                    placeholder="e.g., Customer Support Bot, Data Analytics Agent"
                  />
                  {field.state.meta.errors.length > 0 && (
                    <p className="text-sm text-red-600">
                      {field.state.meta.errors.join(", ")}
                    </p>
                  )}
                </div>
              )}
            </form.Field>

            <form.Subscribe
              selector={(state) => state.values.name}
              children={(name) => {
                const computedSlug = computeSlug(name);
                return (
                  <form.Field name="agentSlug">
                    {(field) => {
                      // Update the field value when the computed identifier changes
                      if (field.state.value !== computedSlug) {
                        field.handleChange(computedSlug);
                      }
                      return (
                        <div className="space-y-2">
                          <Label htmlFor={field.name}>Agent Slug</Label>
                          <p className="text-sm text-muted-foreground">
                            This slug is used to identify the agent in the
                            API. It's automatically computed from the agent
                            name.
                          </p>
                          <Input
                            id={field.name}
                            name={field.name}
                            value={computedSlug}
                            readOnly
                            className="bg-muted cursor-text"
                          />
                        </div>
                      );
                    }}
                  </form.Field>
                );
              }}
            />

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Label className="text-lg">Restricted Agent</Label>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <HelpCircle className="h-4 w-4 text-muted-foreground cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Restricted agents require customer linking for access control</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
                <Switch
                  checked={isRestrictedAgent}
                  onCheckedChange={handleRestrictedChange}
                  disabled={setupFeeEnabled || platformFeeEnabled}
                />
              </div>
              {isRestrictedAgent && (
                <p className="text-sm text-muted-foreground">
                  Agent access is restricted. Only linked customers can use this agent.
                  {(setupFeeEnabled || platformFeeEnabled) && " (Auto-enabled due to fees)"}
                </p>
              )}
            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Label className="text-lg">Usage-based Signals</Label>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <HelpCircle className="h-4 w-4 text-muted-foreground cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Examples: API calls ($0.01), file uploads ($0.05), data processing ($0.10)</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setShowAddSignal(true)}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Add Usage Signal
                </Button>
              </div>
              <p className="text-sm text-muted-foreground">
                Define billable operations that this agent can perform. Each signal tracks usage and applies the specified price per call.
              </p>

              {signals.length > 0 && (
                <div className="space-y-2">
                  {signals.map((signal, index) => (
                    <SignalCard
                      key={index}
                      signal={signal}
                      index={index}
                      isEditing={editingIndex === index}
                      onEdit={() => handleEditSignal(index)}
                      onSave={(updatedSignal) => handleSaveSignal(index, updatedSignal)}
                      onCancel={handleCancelEdit}
                      onRemove={() => handleRemoveSignal(index)}
                      computeSlug={computeSlug}
                    />
                  ))}
                </div>
              )}

              {showAddSignal && (
                <div className="space-y-4 border p-4 rounded-lg bg-muted/20">
                  <div className="space-y-2">
                    <Label htmlFor="signal-name">Signal Name</Label>
                    <p className="text-sm text-muted-foreground">
                      Give your signal a descriptive name that clearly identifies the operation being tracked.
                    </p>
                    <Input
                      id="signal-name"
                      value={newSignalName}
                      onChange={(e) => setNewSignalName(e.target.value)}
                      placeholder="e.g., API Call, Data Processing, File Upload"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="signal-price">Price per Usage (USD)</Label>
                    <p className="text-sm text-muted-foreground">
                      Set the cost charged each time this signal is triggered.
                    </p>
                    <Input
                      id="signal-price"
                      type="text"
                      value={newSignalPriceRaw}
                      onChange={(e) => {
                        const value = e.target.value;
                        if (value === '' || /^\d*\.?\d*$/.test(value)) {
                          setNewSignalPriceRaw(value);
                        }
                      }}
                      onBlur={() => {
                        if (newSignalPriceRaw) {
                          const cents = parseCurrencyInput(newSignalPriceRaw);
                          setNewSignalPriceCents(cents);
                          setNewSignalPriceRaw(formatCurrencyInput(cents));
                        }
                      }}
                      placeholder="Price in USD"
                    />
                  </div>
                  <div className="flex gap-2">
                    <Button
                      type="button"
                      onClick={() => {
                        handleAddSignal();
                        setShowAddSignal(false);
                      }}
                      disabled={!newSignalName.trim()}
                    >
                      <Check className="h-4 w-4 mr-2" />
                      Save Signal
                    </Button>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => {
                        setShowAddSignal(false);
                        setNewSignalName("");
                        setNewSignalPriceRaw("");
                        setNewSignalPriceCents(0);
                      }}
                    >
                      <X className="h-4 w-4 mr-2" />
                      Cancel
                    </Button>
                  </div>
                </div>
              )}

            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Label className="text-lg">Outcome-based Signals</Label>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <HelpCircle className="h-4 w-4 text-muted-foreground cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Examples: successful conversions ($5.00), completed tasks ($2.50), resolved issues ($1.00)</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setShowAddOutcomeSignal(true)}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Add Outcome Signal
                </Button>
              </div>
              <p className="text-sm text-muted-foreground">
                Charge based on successful results or achievements. These signals trigger billing only when specific outcomes are reached.
              </p>

              {outcomeSignals.length > 0 && (
                <div className="space-y-2">
                  {outcomeSignals.map((signal, index) => (
                    <SignalCard
                      key={index}
                      signal={signal}
                      index={index}
                      isEditing={editingOutcomeIndex === index}
                      onEdit={() => handleEditOutcomeSignal(index)}
                      onSave={(updatedSignal) => handleSaveOutcomeSignal(index, updatedSignal)}
                      onCancel={handleCancelOutcomeEdit}
                      onRemove={() => handleRemoveOutcomeSignal(index)}
                      computeSlug={computeSlug}
                    />
                  ))}
                </div>
              )}

              {showAddOutcomeSignal && (
                <div className="space-y-4 border p-4 rounded-lg bg-muted/20">
                  <div className="space-y-2">
                    <Label htmlFor="outcome-signal-name">Signal Name</Label>
                    <p className="text-sm text-muted-foreground">
                      Give your outcome signal a descriptive name that clearly identifies the successful result being tracked.
                    </p>
                    <Input
                      id="outcome-signal-name"
                      value={newOutcomeSignalName}
                      onChange={(e) => setNewOutcomeSignalName(e.target.value)}
                      placeholder="e.g., Sale Conversion, Task Completion, Issue Resolution"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="outcome-signal-price">Price per Outcome (USD)</Label>
                    <p className="text-sm text-muted-foreground">
                      Set the cost charged when this successful outcome is achieved.
                    </p>
                    <Input
                      id="outcome-signal-price"
                      type="text"
                      value={newOutcomeSignalPriceRaw}
                      onChange={(e) => {
                        const value = e.target.value;
                        if (value === '' || /^\d*\.?\d*$/.test(value)) {
                          setNewOutcomeSignalPriceRaw(value);
                        }
                      }}
                      onBlur={() => {
                        if (newOutcomeSignalPriceRaw) {
                          const cents = parseCurrencyInput(newOutcomeSignalPriceRaw);
                          setNewOutcomeSignalPriceCents(cents);
                          setNewOutcomeSignalPriceRaw(formatCurrencyInput(cents));
                        }
                      }}
                      placeholder="Price in USD"
                    />
                  </div>
                  <div className="flex gap-2">
                    <Button
                      type="button"
                      onClick={() => {
                        handleAddOutcomeSignal();
                        setShowAddOutcomeSignal(false);
                      }}
                      disabled={!newOutcomeSignalName.trim()}
                    >
                      <Check className="h-4 w-4 mr-2" />
                      Save Signal
                    </Button>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => {
                        setShowAddOutcomeSignal(false);
                        setNewOutcomeSignalName("");
                        setNewOutcomeSignalPriceRaw("");
                        setNewOutcomeSignalPriceCents(0);
                      }}
                    >
                      <X className="h-4 w-4 mr-2" />
                      Cancel
                    </Button>
                  </div>
                </div>
              )}

            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Label className="text-lg">Credit-based Signals</Label>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <HelpCircle className="h-4 w-4 text-muted-foreground cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Examples: premium features (5 credits), advanced analytics (10 credits), priority support (3 credits)</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setShowAddCreditSignal(true)}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Add Credit Signal
                </Button>
              </div>
              <p className="text-sm text-muted-foreground">
                Track operations that consume credits from a customer's balance. Each usage deducts the specified number of credits.
              </p>

              {creditSignals.length > 0 && (
                <div className="space-y-2">
                  {creditSignals.map((signal, index) => (
                    <CreditSignalCard
                      key={index}
                      signal={signal}
                      index={index}
                      isEditing={editingCreditIndex === index}
                      onEdit={() => handleEditCreditSignal(index)}
                      onSave={(updatedSignal) => handleSaveCreditSignal(index, updatedSignal)}
                      onCancel={handleCancelCreditEdit}
                      onRemove={() => handleRemoveCreditSignal(index)}
                      computeSlug={computeSlug}
                    />
                  ))}
                </div>
              )}

              {showAddCreditSignal && (
                <div className="space-y-4 border p-4 rounded-lg bg-muted/20">
                  <div className="space-y-2">
                    <Label htmlFor="credit-signal-name">Signal Name</Label>
                    <p className="text-sm text-muted-foreground">
                      Give your credit signal a descriptive name that clearly identifies the operation being tracked.
                    </p>
                    <Input
                      id="credit-signal-name"
                      value={newCreditSignalName}
                      onChange={(e) => setNewCreditSignalName(e.target.value)}
                      placeholder="e.g., Premium Feature Access, Advanced Analytics, Priority Support"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="credit-signal-credits">Credits per Usage</Label>
                    <p className="text-sm text-muted-foreground">
                      Set the number of credits consumed each time this signal is triggered.
                    </p>
                    <Input
                      id="credit-signal-credits"
                      type="text"
                      value={newCreditSignalCreditsRaw}
                      onChange={(e) => {
                        const value = e.target.value;
                        if (value === '' || /^\d*\.?\d*$/.test(value)) {
                          setNewCreditSignalCreditsRaw(value);
                        }
                      }}
                      onBlur={() => {
                        if (newCreditSignalCreditsRaw) {
                          const cents = parseCurrencyInput(newCreditSignalCreditsRaw);
                          setNewCreditSignalCreditsCents(cents);
                          setNewCreditSignalCreditsRaw(formatCurrencyInput(cents));
                        }
                      }}
                      placeholder="Credits per usage"
                    />
                  </div>
                  <div className="flex gap-2">
                    <Button
                      type="button"
                      onClick={() => {
                        handleAddCreditSignal();
                        setShowAddCreditSignal(false);
                      }}
                      disabled={!newCreditSignalName.trim()}
                    >
                      <Check className="h-4 w-4 mr-2" />
                      Save Signal
                    </Button>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => {
                        setShowAddCreditSignal(false);
                        setNewCreditSignalName("");
                        setNewCreditSignalCreditsRaw("");
                        setNewCreditSignalCreditsCents(0);
                      }}
                    >
                      <X className="h-4 w-4 mr-2" />
                      Cancel
                    </Button>
                  </div>
                </div>
              )}

            </div>

            <form.Subscribe
              selector={(state) => [state.canSubmit, state.isSubmitting]}
            >
              {([canSubmit, isSubmitting]) => (
                <div className="flex gap-4">
                  <Button type="submit" disabled={!canSubmit}>
                    {isSubmitting
                      ? "..."
                      : isNewAgent
                        ? "Create Agent"
                        : "Save Changes"}
                  </Button>
                  <Button
                    type="button"
                    variant="outline"
                    onClick={handleCancel}
                  >
                    Cancel
                  </Button>
                </div>
              )}
            </form.Subscribe>
          </form>
        </CardContent>
      </Card>

      <div className="flex flex-col gap-4 w-80">
        <TooltipProvider>
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <CardTitle className="text-lg">Setup Fee</CardTitle>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <HelpCircle className="h-4 w-4 text-muted-foreground cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>A fixed one-time fee charged when a customer first uses this agent</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
                <Switch
                  checked={setupFeeEnabled}
                  onCheckedChange={setSetupFeeEnabled}
                />
              </div>
              {setupFeeEnabled && (
                <CardDescription>
                  Fixed one-time fee charged when a customer first uses this agent
                </CardDescription>
              )}
            </CardHeader>
            {setupFeeEnabled && (
              <CardContent>
                <div className="space-y-2">
                  <Label>Amount (USD)</Label>
                  <Input
                    type="text"
                    value={setupFeeRaw}
                    onChange={(e) => {
                      const value = e.target.value;
                      if (value === '' || /^\d*\.?\d*$/.test(value)) {
                        setSetupFeeRaw(value);
                      }
                    }}
                    onBlur={() => {
                      if (setupFeeRaw) {
                        const cents = parseCurrencyInput(setupFeeRaw);
                        setSetupFeeCents(cents);
                        setSetupFeeRaw(formatCurrencyInput(cents));
                      }
                    }}
                    placeholder="Price in USD"
                  />
                </div>
              </CardContent>
            )}
          </Card>

          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <CardTitle className="text-lg">Platform Fee</CardTitle>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <HelpCircle className="h-4 w-4 text-muted-foreground cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>A fixed recurring fee charged per billing cycle (monthly/yearly) for this agent</p>
                    </TooltipContent>
                  </Tooltip>
                </div>
                <Switch
                  checked={platformFeeEnabled}
                  onCheckedChange={setPlatformFeeEnabled}
                />
              </div>
              {platformFeeEnabled && (
                <CardDescription>
                  Fixed recurring fee charged per billing cycle for this agent
                </CardDescription>
              )}
            </CardHeader>
            {platformFeeEnabled && (
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label>Amount (USD)</Label>
                    <Input
                      type="text"
                      value={platformFeeRaw}
                      onChange={(e) => {
                        const value = e.target.value;
                        if (value === '' || /^\d*\.?\d*$/.test(value)) {
                          setPlatformFeeRaw(value);
                        }
                      }}
                      onBlur={() => {
                        if (platformFeeRaw) {
                          const cents = parseCurrencyInput(platformFeeRaw);
                          setPlatformFeeCents(cents);
                          setPlatformFeeRaw(formatCurrencyInput(cents));
                        }
                      }}
                      placeholder="Price in USD"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label>Billing Cycle</Label>
                    <Select value={platformFeeBillingCycle} onValueChange={(value) => setPlatformFeeBillingCycle(value as BillingCycle)}>
                      <SelectTrigger>
                        <SelectValue placeholder="Select billing cycle" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value={BILLING_CYCLES.MONTHLY}>Monthly</SelectItem>
                        <SelectItem value={BILLING_CYCLES.YEARLY}>Yearly</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>
              </CardContent>
            )}
          </Card>

          <AlertDialog open={showRestrictedDialog} onOpenChange={setShowRestrictedDialog}>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Agent Restricted</AlertDialogTitle>
                <AlertDialogDescription>
                  This agent is now restricted. Only customers that are explicitly linked to this agent will be able to use it.
                  {setupFeeEnabled && platformFeeEnabled && " This was automatically enabled because both setup and platform fees are active."}
                  {setupFeeEnabled && !platformFeeEnabled && " This was automatically enabled because setup fee is active."}
                  {!setupFeeEnabled && platformFeeEnabled && " This was automatically enabled because platform fee is active."}
                  {!setupFeeEnabled && !platformFeeEnabled && " You can manage customer access through the Customer edit pages."}
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogAction onClick={() => setShowRestrictedDialog(false)}>
                Got it
              </AlertDialogAction>
            </AlertDialogContent>
          </AlertDialog>
        </TooltipProvider>
      </div>
    </div>
    </div>
  );
}
